https://www.zhihu.com/question/60949531
https://www.cnblogs.com/java1024/p/7685400.html

高并发、高可用分布式方案


### 基础知识
 1. ArrayList和Vector的区别,HashMap和Hashtable的区别,LinkedList与ArrayList区别,数组(Array)和列表集合(ArrayList)区别,HashSet和TreeSet区别,Enumeration接口和Iterator接口的区别
    * ArrayList和Vector的区别
        Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是
        Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小
    * HashMap和Hashtable的区别

    * Enumeration接口和Iterator接口的区别
        Vector（包括其子类Stack）、Hashtable两个集合类，都是从JDK1.遗留下来的集合类，
        而Enumeration接口可用于遍历这些“古老”的集合类。对于ArrayList、HashMap等集合类，
        不再支持使用Enumeration迭代器。

        http://blog.csdn.net/wxc880924/article/details/52639701
        http://blog.csdn.net/wxc880924/article/details/52315236
        ![](http://img.blog.csdn.net/20160919165245696)
 2. 垃圾回收机制,如何优化程序?
 3. java集合 集合关系
 4. equal 与 ==
 5. equal hash
 6. 抽象类（abstract class）和接口（interface）有什么异同？
    >抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。
 7. 运行时异常与受检异常有何异同？

    　　异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，
    只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。
    Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。
    异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：
    - 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
    - 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
    - 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
    - 优先使用标准的异常
    - 每个方法抛出的异常都要有文档
    - 保持异常的原子性
    - 不要在catch中忽略掉捕获到的异常
 8. 常见的运行时异常？
    - ArithmeticException（算术异常）
    - ClassCastException （类转换异常）
    - IllegalArgumentException （非法参数异常）
    - IndexOutOfBoundsException （下标越界异常）
    - NullPointerException （空指针异常）
    - SecurityException （安全异常）
 9. CountDownLatch(闭锁) 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行
       >是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier(栅栏)、Semaphore、ConcurrentHashMap和BlockingQueue，
       它们都存在于java.util.concurrent包下

       参考：
       >http://www.importnew.com/15731.html
       >https://www.cnblogs.com/geningchao/p/6638781.html
       >http://www.infoq.com/cn/articles/java-blocking-queue


### 高级
1. 如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？
        http://blog.csdn.net/csh624366188/article/details/7651702/
2. 解释一下什么叫AOP（面向切面编程）
3. Spring中Bean的作用域有哪些
    - singleton和prototype

    - request,session,globalSession
        - request（每次HTTP请求都会创建一个新的Bean）、
        - session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）
        - globalSession（同一个全局Session共享一个Bean）
4. Spring MVC的工作原理是怎样的？
   > ![](http://img.blog.csdn.net/20150414170229132)

5. spring理解


    * 轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。

    * 控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。

    * 面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。

    * 容器：Spring包含并管理应用程序对象的配置及生命周期。

    * MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。

    * 事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。

    * 异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。

    http://www.importnew.com/11657.html

- 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。
- IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。
- AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。
- MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。
- 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。



6. 什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？

7. 什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？
    - XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。
- SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。
- CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验
8. 应用服务器优化技术有哪些？
    - 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题：
- 频繁修改的数据；
- 数据不一致与脏读；
- 缓存雪崩（可以采用分布式缓存服务器集群加以解决，memcached是广泛采用的解决方案）；
- 缓存预热；
- 缓存穿透（恶意持续请求不存在的数据）。
- 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。
- 使用集群。
- 代码优化：
- 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。
- 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。
- 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。
9. 大型网站在架构上应当考虑哪些问题？
10.

redis memcache
负载均衡
分库分表
    https://www.cnblogs.com/hhandbibi/p/7118740.html
    http://blog.csdn.net/xlgen157387/article/details/53976153
    [水平分库分表的关键步骤和技术难点ID生成算法](http://blog.csdn.net/dinglang_2009/article/details/53195871)
单点登录
    https://zhuanlan.zhihu.com/p/25007591
    http://blog.csdn.net/u011277123/article/details/53404269
    https://www.cnblogs.com/hujunzheng/p/6395966.html?from=singlemessage
    http://blog.csdn.net/gzseehope/article/details/72914188
    https://www.cnblogs.com/lihuidu/p/6495247.html

    https://www.jianshu.com/p/d94bb118aa43
    http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

并发 并发优缺点、内存可见性（volatile）、锁、同步、线程池框架
分布式 一致性哈希、RPC原理和设计（通信协议、序列化方式、超时机制等）、负载均衡、分布式缓存架构设计、分布式消息、分布式事务、
paxos（这个可能只有在技术专业型很强的职位上会去问）数据库 数据库性能优化（慢sql、索引优化、大事务、内核参数调优），也可能会把一些工作中碰到的诡异场景抛出来问
concurrenthashmap

分布式锁
https://www.cnblogs.com/austinspark-jessylu/p/8043726.html



[JAVA中静态块、静态变量加载顺序](http://blog.csdn.net/mrzhoug/article/details/51581994)

参考以下：
[Java面试题全集（下）](http://www.importnew.com/22087.html)






总的经验：知识点准备+数据结构与算法+面试技巧

1. 知识点准备，主要包括：计算机网络、操作系统、关系型数据库、非关系型数据库、linux、编程语言、项目及实习。这一部分只要是认真准备，一般问题不会太大。

2. 数据结构与算法，这个比较突出硬实力，面过的每个公司都是需要手撸几个算法题，所以需要尽早刷题准备。（之所以单独列为一项，是因为楼主就是有几家公司死在这里的）

3. 面试技巧：

第一点，每一次面试后认真总结，很可能下一次面试又碰上这次不会的原题（亲身经历）；

第二点，遇到自己研究比较好的知识点，可以引导面试官问，往底层说（但是千万要自己有把握），这样如果一次面试有1到2个问题可以说的比较深入，面试官对你的印象会很好（屡试不爽）；

第三点，放低身段，面对面试官的嘲讽之类的（比如嫌你low、对你的研究方向一片否定），尽量解释，不要怼面试官，要忍得住；实在忍不住，就怼个痛快（我试过，顺利挂了）。

第四点，自信、自信、自信。相信自己，勇敢的去面试，即是被虐。相信自己，而且面试技巧也都是在一次次被虐中成长起来的。

下面是我自己总结的一点知识点的干货，若low，勿喷：

计算机网络：

1. OSI七层协议、TCP/IP四层协议

2. 各层对应的网络设备（路由器、交换机、网关、网桥、集线器等等），各层对应的协议

3. 数据链路层的CSMA/CD协议，笔试可能会用到

4. IP地址分类，子网划分（笔试常用）

5. TCP和UDP的区别

6. TCP三次握手和四次挥手，为什么三次握手，为什么四次挥手

7. TCP精髓问题：停止等待协议、连续ARQ协议、滑动窗口、流量控制、拥塞控制（慢开始、拥塞避免、快重传、快恢复）

8. 从浏览器输入www.baidu.com到加载出页面发生了什么

9. GET和POST区别

10. HTTP状态码，HTTP1.0和HTTP1.1区别

11. HTTP缓存机制（cache-control、Expires之类的一系列请求与相应报头字段）

12. session和cookie的区别，禁用cookie后怎么办

13. DNS解析的过程

14. 常用协议的端口

推荐：计算机网络（谢希仁）、TCP/IP详解、HTTP权威指南，大神可以看一下RCF2616之类的

数据库:

Mysql：

1. 数据库三范式及判断、E-R图

2. innodb和myisam存储引擎的区别

3. 索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引

4. B树、B+树区别，索引为何使用B+树

5. 聚集索引与非聚集索引（使用非聚集索引的查询过程）

6. 事务的ACID（原子性、一致性、隔离性、持久性）

7. 事务隔离级别和各自存在的问题（脏读、不可重复读、幻读）和解决方式（间隙锁及MVCC）

8. 乐观锁和悲观锁、行锁与表锁、共享锁与排他锁（inndob如何手动加共享锁与排他锁）

9. MVCC（增加两个版本号）及delete、update、select时的具体控制

10. 死锁判定原理和具体场景

11. 查询缓慢和解决方式（explain、慢查询日志、show profile等）

12. drop、truncate、delete区别

13.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序

14. mysql优化，读写分离、主从复制

15. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）

Redis:

1.发布订阅

2.数据淘汰机制（好几种）

3.字典及渐进式rehash

4.RDB与AOF

5.为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）

6. Redis的几种数据结构

推荐：MySQL数据库应用从入门到精通（王飞飞，虽然名字很low）、高性能Mysql、Redis设计与实现、Redis实战

数据结构与算法：

1. 数组、链表（单向、双向、双端）、栈和队列、二叉树、红黑树、哈希表、堆（最大和最小）、图

2. 个人经验：栈和队列、哈希表、链表、二叉树的题较多，图的较少

3. 查找：二分查找及其变形

4. 二叉树：前序、中序、后序遍历，按规定方式打印，两个节点之间操作（最近公共祖先、距离）等问题。

5. 最大堆和最小堆：大数量级数据找最大几个等问题、堆如何调整等问题。

6. 图：深度优先、广度优先、单源最小路径Dijkstra，任意两点间最短路径Floyd-Warshall，最小生成树Prime和Kruskal

7. 红黑树：特点及如何调整（基本上没人让你手撸红黑树）

8. 栈和队列：经常作为算法题要用到的数据结构

8. 八大排序：3个简单的：冒泡、选择、插入及其优化，5个高级的：快速排序、归并排序、堆排序、希尔排序、桶排序（快排、归并、堆很重要，经常手撸）

9. 时间复杂度及空间复杂度分析

10. 动态规划dp：这个比较难，背包问题之内的

推荐：数据结构C语言版（严蔚敏）、java数据结构和算法（Robert Lafore）、剑指offer及leetcode刷题、大神可以看一下算法导论

Linux:

1. 常用命令：用户控制、权限控制、进程控制、系统状态查询之类的

2. Linux状态分析：CPU（top）、内存（top和free，注意buffer和cache区别）、磁盘（fdisk和df）、IO（iostat）等

3. grep和sed

4. awk（用好awk，脚本写得好）

5. shell脚本

6. Linux目录结构（尤其是/proc非常重要）

7. linux文件系统结构和启动流程

8. 防火墙iptables（这个比较少）

推荐：鸟哥私房菜、视频（马哥的一套 http://pan.baidu.com/s/1pL3HGT1）

操作系统：

1. 一个二进制文件运行出结果，操作系统做了什么（这是一个很全面的题）

2. 死锁的条件及银行家算法、资源分配图之类的

3. 进程间通信方式

4. linux的五种IO方式（阻塞与非阻塞、同步与异步的理解）

5. linux的select、poll、epoll的区别

6. 进程与线程区别、内核级线程与用户级线程

7. 页面置换算法，尤其是lru

8. 进程调度算法

9. linux中断响应机制

10. 虚拟内存机制